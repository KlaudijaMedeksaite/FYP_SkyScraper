XPATHS: 
// — this means to search the whole HTML document (start at the root of the site and look for everything that matches the expression we’re looking for)

p — this is an HTML tag that contains another tag that has the text we’re looking for.
strong — this is an HTML tag that actually has the text we’re looking for

text() — this selects text nodes.

[ ] — you can see part of the expression is enclosed in square brackets. This is called a “predicate”, and it is used to filter the nodes based on the criteria specified inside it. In this case, it would filter the nodes that “//p” alone would normally output.

contains() — this searches the first argument for instances where the second argument is present. In this case, we are searching for all the text that includes “Use”.

not() — this takes a specified boolean condition and returns the “False” value.

starts-with — This works just like “contains”, except this time we look at the beginning of nodes specified by the first argument for a sub-string provided by the second argument.

@ — This is how to select an “attribute” with XPath. Attributes are pieces of HTML after the opening tag that modifies the original element’s function.

[@something=“something” ] — Here, instead of looking for an attribute value that contains or starts with something, we specify in the predicate directly that we want an exact match.

descendant::node() — This allows us to search for all nodes that come after the preceding tag.

https://towardsdatascience.com/how-to-use-python-and-xpath-to-scrape-websites-99eaed73f1dd